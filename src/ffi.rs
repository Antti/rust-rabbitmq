/* automatically generated by rust-bindgen */

pub type __int128_t = ::libc::c_void;
pub type __uint128_t = ::libc::c_void;
pub type __builtin_va_list = [__va_list_tag, ..1u];
pub type ptrdiff_t = ::libc::c_long;
pub type size_t = ::libc::c_ulong;
pub type wchar_t = ::libc::c_int;
pub type int8_t = ::libc::c_char;
pub type int16_t = ::libc::c_short;
pub type int32_t = ::libc::c_int;
pub type int64_t = ::libc::c_longlong;
pub type uint8_t = ::libc::c_uchar;
pub type uint16_t = ::libc::c_ushort;
pub type uint32_t = ::libc::c_uint;
pub type uint64_t = ::libc::c_ulonglong;
pub type int_least8_t = int8_t;
pub type int_least16_t = int16_t;
pub type int_least32_t = int32_t;
pub type int_least64_t = int64_t;
pub type uint_least8_t = uint8_t;
pub type uint_least16_t = uint16_t;
pub type uint_least32_t = uint32_t;
pub type uint_least64_t = uint64_t;
pub type int_fast8_t = int8_t;
pub type int_fast16_t = int16_t;
pub type int_fast32_t = int32_t;
pub type int_fast64_t = int64_t;
pub type uint_fast8_t = uint8_t;
pub type uint_fast16_t = uint16_t;
pub type uint_fast32_t = uint32_t;
pub type uint_fast64_t = uint64_t;
pub type __int8_t = ::libc::c_char;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __darwin_intptr_t = ::libc::c_long;
pub type __darwin_natural_t = ::libc::c_uint;
pub type __darwin_ct_rune_t = ::libc::c_int;
#[repr(C)]
pub struct __mbstate_t {
    pub data: [u64, ..16u],
}
impl __mbstate_t {
    pub fn __mbstate8(&mut self) -> *mut [::libc::c_char, ..128u] {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn _mbstateL(&mut self) -> *mut ::libc::c_longlong {
        unsafe { ::std::mem::transmute(self) }
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::libc::c_long;
pub type __darwin_size_t = ::libc::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::libc::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::libc::c_int;
pub type __darwin_clock_t = ::libc::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::libc::c_long;
pub type __darwin_time_t = ::libc::c_long;
#[repr(C)]
pub struct Struct___darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<extern "C" fn
                                             (arg1: *mut ::libc::c_void)>,
    pub __arg: *mut ::libc::c_void,
    pub __next: *mut Struct___darwin_pthread_handler_rec,
}
#[repr(C)]
pub struct Struct__opaque_pthread_attr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..56u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_cond_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..40u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_condattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..8u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_mutex_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..56u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_mutexattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..8u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_once_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..8u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_rwlock_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..192u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_rwlockattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char, ..16u],
}
#[repr(C)]
pub struct Struct__opaque_pthread_t {
    pub __sig: ::libc::c_long,
    pub __cleanup_stack: *mut Struct___darwin_pthread_handler_rec,
    pub __opaque: [::libc::c_char, ..1168u],
}
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::libc::c_uint;
pub type __darwin_fsfilcnt_t = ::libc::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_pthread_attr_t = Struct__opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = Struct__opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = Struct__opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::libc::c_ulong;
pub type __darwin_pthread_mutex_t = Struct__opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = Struct__opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = Struct__opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = Struct__opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = Struct__opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut Struct__opaque_pthread_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::libc::c_uchar, ..16u];
pub type __darwin_uuid_string_t = [::libc::c_char, ..37u];
pub type intptr_t = __darwin_intptr_t;
pub type uintptr_t = ::libc::c_ulong;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
pub type amqp_boolean_t = ::libc::c_int;
pub type amqp_method_number_t = uint32_t;
pub type amqp_flags_t = uint32_t;
pub type amqp_channel_t = uint16_t;
#[repr(C)]
pub struct Struct_amqp_bytes_t_ {
    pub len: size_t,
    pub bytes: *mut ::libc::c_void,
}
pub type amqp_bytes_t = Struct_amqp_bytes_t_;
#[repr(C)]
pub struct Struct_amqp_decimal_t_ {
    pub decimals: uint8_t,
    pub value: uint32_t,
}
pub type amqp_decimal_t = Struct_amqp_decimal_t_;
#[repr(C)]
pub struct Struct_amqp_table_t_ {
    pub num_entries: ::libc::c_int,
    pub entries: *mut Struct_amqp_table_entry_t_,
}
pub type amqp_table_t = Struct_amqp_table_t_;
#[repr(C)]
pub struct Struct_amqp_array_t_ {
    pub num_entries: ::libc::c_int,
    pub entries: *mut Struct_amqp_field_value_t_,
}
pub type amqp_array_t = Struct_amqp_array_t_;
#[repr(C)]
pub struct Struct_amqp_field_value_t_ {
    pub kind: uint8_t,
    pub value: Union_Unnamed1,
}
#[repr(C)]
pub struct Union_Unnamed1 {
    pub data: [u64, ..2u],
}
impl Union_Unnamed1 {
    pub fn boolean(&mut self) -> *mut amqp_boolean_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn i8(&mut self) -> *mut int8_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn u8(&mut self) -> *mut uint8_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn i16(&mut self) -> *mut int16_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn u16(&mut self) -> *mut uint16_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn i32(&mut self) -> *mut int32_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn u32(&mut self) -> *mut uint32_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn i64(&mut self) -> *mut int64_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn u64(&mut self) -> *mut uint64_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn f32(&mut self) -> *mut ::libc::c_float {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn f64(&mut self) -> *mut ::libc::c_double {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn decimal(&mut self) -> *mut amqp_decimal_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn bytes(&mut self) -> *mut amqp_bytes_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn table(&mut self) -> *mut amqp_table_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn array(&mut self) -> *mut amqp_array_t {
        unsafe { ::std::mem::transmute(self) }
    }
}
pub type amqp_field_value_t = Struct_amqp_field_value_t_;
#[repr(C)]
pub struct Struct_amqp_table_entry_t_ {
    pub key: amqp_bytes_t,
    pub value: amqp_field_value_t,
}
pub type amqp_table_entry_t = Struct_amqp_table_entry_t_;
pub type amqp_field_value_kind_t = ::libc::c_uint;
pub static AMQP_FIELD_KIND_BOOLEAN: ::libc::c_uint = 116;
pub static AMQP_FIELD_KIND_I8: ::libc::c_uint = 98;
pub static AMQP_FIELD_KIND_U8: ::libc::c_uint = 66;
pub static AMQP_FIELD_KIND_I16: ::libc::c_uint = 115;
pub static AMQP_FIELD_KIND_U16: ::libc::c_uint = 117;
pub static AMQP_FIELD_KIND_I32: ::libc::c_uint = 73;
pub static AMQP_FIELD_KIND_U32: ::libc::c_uint = 105;
pub static AMQP_FIELD_KIND_I64: ::libc::c_uint = 108;
pub static AMQP_FIELD_KIND_U64: ::libc::c_uint = 76;
pub static AMQP_FIELD_KIND_F32: ::libc::c_uint = 102;
pub static AMQP_FIELD_KIND_F64: ::libc::c_uint = 100;
pub static AMQP_FIELD_KIND_DECIMAL: ::libc::c_uint = 68;
pub static AMQP_FIELD_KIND_UTF8: ::libc::c_uint = 83;
pub static AMQP_FIELD_KIND_ARRAY: ::libc::c_uint = 65;
pub static AMQP_FIELD_KIND_TIMESTAMP: ::libc::c_uint = 84;
pub static AMQP_FIELD_KIND_TABLE: ::libc::c_uint = 70;
pub static AMQP_FIELD_KIND_VOID: ::libc::c_uint = 86;
pub static AMQP_FIELD_KIND_BYTES: ::libc::c_uint = 120;
#[repr(C)]
pub struct Struct_amqp_pool_blocklist_t_ {
    pub num_blocks: ::libc::c_int,
    pub blocklist: *mut *mut ::libc::c_void,
}
pub type amqp_pool_blocklist_t = Struct_amqp_pool_blocklist_t_;
#[repr(C)]
pub struct Struct_amqp_pool_t_ {
    pub pagesize: size_t,
    pub pages: amqp_pool_blocklist_t,
    pub large_blocks: amqp_pool_blocklist_t,
    pub next_page: ::libc::c_int,
    pub alloc_block: *mut ::libc::c_char,
    pub alloc_used: size_t,
}
pub type amqp_pool_t = Struct_amqp_pool_t_;
#[repr(C)]
pub struct Struct_amqp_method_t_ {
    pub id: amqp_method_number_t,
    pub decoded: *mut ::libc::c_void,
}
pub type amqp_method_t = Struct_amqp_method_t_;
#[repr(C)]
pub struct Struct_amqp_frame_t_ {
    pub frame_type: uint8_t,
    pub channel: amqp_channel_t,
    pub payload: Union_Unnamed2,
}
#[repr(C)]
pub struct Union_Unnamed2 {
    pub data: [u64, ..5u],
}
impl Union_Unnamed2 {
    pub fn method(&mut self) -> *mut amqp_method_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn properties(&mut self) -> *mut Struct_Unnamed3 {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn body_fragment(&mut self) -> *mut amqp_bytes_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn protocol_header(&mut self) -> *mut Struct_Unnamed4 {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_Unnamed3 {
    pub class_id: uint16_t,
    pub body_size: uint64_t,
    pub decoded: *mut ::libc::c_void,
    pub raw: amqp_bytes_t,
}
#[repr(C)]
pub struct Struct_Unnamed4 {
    pub transport_high: uint8_t,
    pub transport_low: uint8_t,
    pub protocol_version_major: uint8_t,
    pub protocol_version_minor: uint8_t,
}
pub type amqp_frame_t = Struct_amqp_frame_t_;
pub type Enum_amqp_response_type_enum_ = ::libc::c_uint;
pub static AMQP_RESPONSE_NONE: ::libc::c_uint = 0;
pub static AMQP_RESPONSE_NORMAL: ::libc::c_uint = 1;
pub static AMQP_RESPONSE_LIBRARY_EXCEPTION: ::libc::c_uint = 2;
pub static AMQP_RESPONSE_SERVER_EXCEPTION: ::libc::c_uint = 3;
pub type amqp_response_type_enum = Enum_amqp_response_type_enum_;
#[repr(C)]
pub struct Struct_amqp_rpc_reply_t_ {
    pub reply_type: amqp_response_type_enum,
    pub reply: amqp_method_t,
    pub library_error: ::libc::c_int,
}
pub type amqp_rpc_reply_t = Struct_amqp_rpc_reply_t_;
pub type Enum_amqp_sasl_method_enum_ = ::libc::c_uint;
pub static AMQP_SASL_METHOD_PLAIN: ::libc::c_uint = 0;
pub type amqp_sasl_method_enum = Enum_amqp_sasl_method_enum_;
pub type amqp_connection_state_t = *mut Struct_amqp_connection_state_t_;
pub type amqp_socket_t = Struct_amqp_socket_t_;
pub type Enum_amqp_status_enum_ = ::libc::c_int;
pub static AMQP_STATUS_OK: ::libc::c_int = 0;
pub static AMQP_STATUS_NO_MEMORY: ::libc::c_int = -1;
pub static AMQP_STATUS_BAD_AMQP_DATA: ::libc::c_int = -2;
pub static AMQP_STATUS_UNKNOWN_CLASS: ::libc::c_int = -3;
pub static AMQP_STATUS_UNKNOWN_METHOD: ::libc::c_int = -4;
pub static AMQP_STATUS_HOSTNAME_RESOLUTION_FAILED: ::libc::c_int = -5;
pub static AMQP_STATUS_INCOMPATIBLE_AMQP_VERSION: ::libc::c_int = -6;
pub static AMQP_STATUS_CONNECTION_CLOSED: ::libc::c_int = -7;
pub static AMQP_STATUS_BAD_URL: ::libc::c_int = -8;
pub static AMQP_STATUS_SOCKET_ERROR: ::libc::c_int = -9;
pub static AMQP_STATUS_INVALID_PARAMETER: ::libc::c_int = -10;
pub static AMQP_STATUS_TABLE_TOO_BIG: ::libc::c_int = -11;
pub static AMQP_STATUS_WRONG_METHOD: ::libc::c_int = -12;
pub static AMQP_STATUS_TIMEOUT: ::libc::c_int = -13;
pub static AMQP_STATUS_TIMER_FAILURE: ::libc::c_int = -14;
pub static AMQP_STATUS_HEARTBEAT_TIMEOUT: ::libc::c_int = -15;
pub static AMQP_STATUS_UNEXPECTED_STATE: ::libc::c_int = -16;
pub static AMQP_STATUS_TCP_ERROR: ::libc::c_int = -256;
pub static AMQP_STATUS_TCP_SOCKETLIB_INIT_ERROR: ::libc::c_int = -257;
pub static AMQP_STATUS_SSL_ERROR: ::libc::c_int = -512;
pub static AMQP_STATUS_SSL_HOSTNAME_VERIFY_FAILED: ::libc::c_int = -513;
pub static AMQP_STATUS_SSL_PEER_VERIFY_FAILED: ::libc::c_int = -514;
pub static AMQP_STATUS_SSL_CONNECTION_FAILED: ::libc::c_int = -515;
pub type amqp_status_enum = Enum_amqp_status_enum_;
pub type amqp_delivery_mode_enum = ::libc::c_uint;
pub static AMQP_DELIVERY_NONPERSISTENT: ::libc::c_uint = 1;
pub static AMQP_DELIVERY_PERSISTENT: ::libc::c_uint = 2;
#[repr(C)]
pub struct Struct_amqp_connection_start_t_ {
    pub version_major: uint8_t,
    pub version_minor: uint8_t,
    pub server_properties: amqp_table_t,
    pub mechanisms: amqp_bytes_t,
    pub locales: amqp_bytes_t,
}
pub type amqp_connection_start_t = Struct_amqp_connection_start_t_;
#[repr(C)]
pub struct Struct_amqp_connection_start_ok_t_ {
    pub client_properties: amqp_table_t,
    pub mechanism: amqp_bytes_t,
    pub response: amqp_bytes_t,
    pub locale: amqp_bytes_t,
}
pub type amqp_connection_start_ok_t = Struct_amqp_connection_start_ok_t_;
#[repr(C)]
pub struct Struct_amqp_connection_secure_t_ {
    pub challenge: amqp_bytes_t,
}
pub type amqp_connection_secure_t = Struct_amqp_connection_secure_t_;
#[repr(C)]
pub struct Struct_amqp_connection_secure_ok_t_ {
    pub response: amqp_bytes_t,
}
pub type amqp_connection_secure_ok_t = Struct_amqp_connection_secure_ok_t_;
#[repr(C)]
pub struct Struct_amqp_connection_tune_t_ {
    pub channel_max: uint16_t,
    pub frame_max: uint32_t,
    pub heartbeat: uint16_t,
}
pub type amqp_connection_tune_t = Struct_amqp_connection_tune_t_;
#[repr(C)]
pub struct Struct_amqp_connection_tune_ok_t_ {
    pub channel_max: uint16_t,
    pub frame_max: uint32_t,
    pub heartbeat: uint16_t,
}
pub type amqp_connection_tune_ok_t = Struct_amqp_connection_tune_ok_t_;
#[repr(C)]
pub struct Struct_amqp_connection_open_t_ {
    pub virtual_host: amqp_bytes_t,
    pub capabilities: amqp_bytes_t,
    pub insist: amqp_boolean_t,
}
pub type amqp_connection_open_t = Struct_amqp_connection_open_t_;
#[repr(C)]
pub struct Struct_amqp_connection_open_ok_t_ {
    pub known_hosts: amqp_bytes_t,
}
pub type amqp_connection_open_ok_t = Struct_amqp_connection_open_ok_t_;
#[repr(C)]
pub struct Struct_amqp_connection_close_t_ {
    pub reply_code: uint16_t,
    pub reply_text: amqp_bytes_t,
    pub class_id: uint16_t,
    pub method_id: uint16_t,
}
pub type amqp_connection_close_t = Struct_amqp_connection_close_t_;
#[repr(C)]
pub struct Struct_amqp_connection_close_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_connection_close_ok_t = Struct_amqp_connection_close_ok_t_;
#[repr(C)]
pub struct Struct_amqp_connection_blocked_t_ {
    pub reason: amqp_bytes_t,
}
pub type amqp_connection_blocked_t = Struct_amqp_connection_blocked_t_;
#[repr(C)]
pub struct Struct_amqp_connection_unblocked_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_connection_unblocked_t = Struct_amqp_connection_unblocked_t_;
#[repr(C)]
pub struct Struct_amqp_channel_open_t_ {
    pub out_of_band: amqp_bytes_t,
}
pub type amqp_channel_open_t = Struct_amqp_channel_open_t_;
#[repr(C)]
pub struct Struct_amqp_channel_open_ok_t_ {
    pub channel_id: amqp_bytes_t,
}
pub type amqp_channel_open_ok_t = Struct_amqp_channel_open_ok_t_;
#[repr(C)]
pub struct Struct_amqp_channel_flow_t_ {
    pub active: amqp_boolean_t,
}
pub type amqp_channel_flow_t = Struct_amqp_channel_flow_t_;
#[repr(C)]
pub struct Struct_amqp_channel_flow_ok_t_ {
    pub active: amqp_boolean_t,
}
pub type amqp_channel_flow_ok_t = Struct_amqp_channel_flow_ok_t_;
#[repr(C)]
pub struct Struct_amqp_channel_close_t_ {
    pub reply_code: uint16_t,
    pub reply_text: amqp_bytes_t,
    pub class_id: uint16_t,
    pub method_id: uint16_t,
}
pub type amqp_channel_close_t = Struct_amqp_channel_close_t_;
#[repr(C)]
pub struct Struct_amqp_channel_close_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_channel_close_ok_t = Struct_amqp_channel_close_ok_t_;
#[repr(C)]
pub struct Struct_amqp_access_request_t_ {
    pub realm: amqp_bytes_t,
    pub exclusive: amqp_boolean_t,
    pub passive: amqp_boolean_t,
    pub active: amqp_boolean_t,
    pub write: amqp_boolean_t,
    pub read: amqp_boolean_t,
}
pub type amqp_access_request_t = Struct_amqp_access_request_t_;
#[repr(C)]
pub struct Struct_amqp_access_request_ok_t_ {
    pub ticket: uint16_t,
}
pub type amqp_access_request_ok_t = Struct_amqp_access_request_ok_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_declare_t_ {
    pub ticket: uint16_t,
    pub exchange: amqp_bytes_t,
    pub _type: amqp_bytes_t,
    pub passive: amqp_boolean_t,
    pub durable: amqp_boolean_t,
    pub auto_delete: amqp_boolean_t,
    pub internal: amqp_boolean_t,
    pub nowait: amqp_boolean_t,
    pub arguments: amqp_table_t,
}
pub type amqp_exchange_declare_t = Struct_amqp_exchange_declare_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_declare_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_exchange_declare_ok_t = Struct_amqp_exchange_declare_ok_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_delete_t_ {
    pub ticket: uint16_t,
    pub exchange: amqp_bytes_t,
    pub if_unused: amqp_boolean_t,
    pub nowait: amqp_boolean_t,
}
pub type amqp_exchange_delete_t = Struct_amqp_exchange_delete_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_delete_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_exchange_delete_ok_t = Struct_amqp_exchange_delete_ok_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_bind_t_ {
    pub ticket: uint16_t,
    pub destination: amqp_bytes_t,
    pub source: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
    pub nowait: amqp_boolean_t,
    pub arguments: amqp_table_t,
}
pub type amqp_exchange_bind_t = Struct_amqp_exchange_bind_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_bind_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_exchange_bind_ok_t = Struct_amqp_exchange_bind_ok_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_unbind_t_ {
    pub ticket: uint16_t,
    pub destination: amqp_bytes_t,
    pub source: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
    pub nowait: amqp_boolean_t,
    pub arguments: amqp_table_t,
}
pub type amqp_exchange_unbind_t = Struct_amqp_exchange_unbind_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_unbind_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_exchange_unbind_ok_t = Struct_amqp_exchange_unbind_ok_t_;
#[repr(C)]
pub struct Struct_amqp_queue_declare_t_ {
    pub ticket: uint16_t,
    pub queue: amqp_bytes_t,
    pub passive: amqp_boolean_t,
    pub durable: amqp_boolean_t,
    pub exclusive: amqp_boolean_t,
    pub auto_delete: amqp_boolean_t,
    pub nowait: amqp_boolean_t,
    pub arguments: amqp_table_t,
}
pub type amqp_queue_declare_t = Struct_amqp_queue_declare_t_;
#[repr(C)]
pub struct Struct_amqp_queue_declare_ok_t_ {
    pub queue: amqp_bytes_t,
    pub message_count: uint32_t,
    pub consumer_count: uint32_t,
}
pub type amqp_queue_declare_ok_t = Struct_amqp_queue_declare_ok_t_;
#[repr(C)]
pub struct Struct_amqp_queue_bind_t_ {
    pub ticket: uint16_t,
    pub queue: amqp_bytes_t,
    pub exchange: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
    pub nowait: amqp_boolean_t,
    pub arguments: amqp_table_t,
}
pub type amqp_queue_bind_t = Struct_amqp_queue_bind_t_;
#[repr(C)]
pub struct Struct_amqp_queue_bind_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_queue_bind_ok_t = Struct_amqp_queue_bind_ok_t_;
#[repr(C)]
pub struct Struct_amqp_queue_purge_t_ {
    pub ticket: uint16_t,
    pub queue: amqp_bytes_t,
    pub nowait: amqp_boolean_t,
}
pub type amqp_queue_purge_t = Struct_amqp_queue_purge_t_;
#[repr(C)]
pub struct Struct_amqp_queue_purge_ok_t_ {
    pub message_count: uint32_t,
}
pub type amqp_queue_purge_ok_t = Struct_amqp_queue_purge_ok_t_;
#[repr(C)]
pub struct Struct_amqp_queue_delete_t_ {
    pub ticket: uint16_t,
    pub queue: amqp_bytes_t,
    pub if_unused: amqp_boolean_t,
    pub if_empty: amqp_boolean_t,
    pub nowait: amqp_boolean_t,
}
pub type amqp_queue_delete_t = Struct_amqp_queue_delete_t_;
#[repr(C)]
pub struct Struct_amqp_queue_delete_ok_t_ {
    pub message_count: uint32_t,
}
pub type amqp_queue_delete_ok_t = Struct_amqp_queue_delete_ok_t_;
#[repr(C)]
pub struct Struct_amqp_queue_unbind_t_ {
    pub ticket: uint16_t,
    pub queue: amqp_bytes_t,
    pub exchange: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
    pub arguments: amqp_table_t,
}
pub type amqp_queue_unbind_t = Struct_amqp_queue_unbind_t_;
#[repr(C)]
pub struct Struct_amqp_queue_unbind_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_queue_unbind_ok_t = Struct_amqp_queue_unbind_ok_t_;
#[repr(C)]
pub struct Struct_amqp_basic_qos_t_ {
    pub prefetch_size: uint32_t,
    pub prefetch_count: uint16_t,
    pub global: amqp_boolean_t,
}
pub type amqp_basic_qos_t = Struct_amqp_basic_qos_t_;
#[repr(C)]
pub struct Struct_amqp_basic_qos_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_basic_qos_ok_t = Struct_amqp_basic_qos_ok_t_;
#[repr(C)]
pub struct Struct_amqp_basic_consume_t_ {
    pub ticket: uint16_t,
    pub queue: amqp_bytes_t,
    pub consumer_tag: amqp_bytes_t,
    pub no_local: amqp_boolean_t,
    pub no_ack: amqp_boolean_t,
    pub exclusive: amqp_boolean_t,
    pub nowait: amqp_boolean_t,
    pub arguments: amqp_table_t,
}
pub type amqp_basic_consume_t = Struct_amqp_basic_consume_t_;
#[repr(C)]
pub struct Struct_amqp_basic_consume_ok_t_ {
    pub consumer_tag: amqp_bytes_t,
}
pub type amqp_basic_consume_ok_t = Struct_amqp_basic_consume_ok_t_;
#[repr(C)]
pub struct Struct_amqp_basic_cancel_t_ {
    pub consumer_tag: amqp_bytes_t,
    pub nowait: amqp_boolean_t,
}
pub type amqp_basic_cancel_t = Struct_amqp_basic_cancel_t_;
#[repr(C)]
pub struct Struct_amqp_basic_cancel_ok_t_ {
    pub consumer_tag: amqp_bytes_t,
}
pub type amqp_basic_cancel_ok_t = Struct_amqp_basic_cancel_ok_t_;
#[repr(C)]
pub struct Struct_amqp_basic_publish_t_ {
    pub ticket: uint16_t,
    pub exchange: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
    pub mandatory: amqp_boolean_t,
    pub immediate: amqp_boolean_t,
}
pub type amqp_basic_publish_t = Struct_amqp_basic_publish_t_;
#[repr(C)]
pub struct Struct_amqp_basic_return_t_ {
    pub reply_code: uint16_t,
    pub reply_text: amqp_bytes_t,
    pub exchange: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
}
pub type amqp_basic_return_t = Struct_amqp_basic_return_t_;
#[repr(C)]
pub struct Struct_amqp_basic_deliver_t_ {
    pub consumer_tag: amqp_bytes_t,
    pub delivery_tag: uint64_t,
    pub redelivered: amqp_boolean_t,
    pub exchange: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
}
pub type amqp_basic_deliver_t = Struct_amqp_basic_deliver_t_;
#[repr(C)]
pub struct Struct_amqp_basic_get_t_ {
    pub ticket: uint16_t,
    pub queue: amqp_bytes_t,
    pub no_ack: amqp_boolean_t,
}
pub type amqp_basic_get_t = Struct_amqp_basic_get_t_;
#[repr(C)]
pub struct Struct_amqp_basic_get_ok_t_ {
    pub delivery_tag: uint64_t,
    pub redelivered: amqp_boolean_t,
    pub exchange: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
    pub message_count: uint32_t,
}
pub type amqp_basic_get_ok_t = Struct_amqp_basic_get_ok_t_;
#[repr(C)]
pub struct Struct_amqp_basic_get_empty_t_ {
    pub cluster_id: amqp_bytes_t,
}
pub type amqp_basic_get_empty_t = Struct_amqp_basic_get_empty_t_;
#[repr(C)]
pub struct Struct_amqp_basic_ack_t_ {
    pub delivery_tag: uint64_t,
    pub multiple: amqp_boolean_t,
}
pub type amqp_basic_ack_t = Struct_amqp_basic_ack_t_;
#[repr(C)]
pub struct Struct_amqp_basic_reject_t_ {
    pub delivery_tag: uint64_t,
    pub requeue: amqp_boolean_t,
}
pub type amqp_basic_reject_t = Struct_amqp_basic_reject_t_;
#[repr(C)]
pub struct Struct_amqp_basic_recover_async_t_ {
    pub requeue: amqp_boolean_t,
}
pub type amqp_basic_recover_async_t = Struct_amqp_basic_recover_async_t_;
#[repr(C)]
pub struct Struct_amqp_basic_recover_t_ {
    pub requeue: amqp_boolean_t,
}
pub type amqp_basic_recover_t = Struct_amqp_basic_recover_t_;
#[repr(C)]
pub struct Struct_amqp_basic_recover_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_basic_recover_ok_t = Struct_amqp_basic_recover_ok_t_;
#[repr(C)]
pub struct Struct_amqp_basic_nack_t_ {
    pub delivery_tag: uint64_t,
    pub multiple: amqp_boolean_t,
    pub requeue: amqp_boolean_t,
}
pub type amqp_basic_nack_t = Struct_amqp_basic_nack_t_;
#[repr(C)]
pub struct Struct_amqp_tx_select_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_tx_select_t = Struct_amqp_tx_select_t_;
#[repr(C)]
pub struct Struct_amqp_tx_select_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_tx_select_ok_t = Struct_amqp_tx_select_ok_t_;
#[repr(C)]
pub struct Struct_amqp_tx_commit_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_tx_commit_t = Struct_amqp_tx_commit_t_;
#[repr(C)]
pub struct Struct_amqp_tx_commit_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_tx_commit_ok_t = Struct_amqp_tx_commit_ok_t_;
#[repr(C)]
pub struct Struct_amqp_tx_rollback_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_tx_rollback_t = Struct_amqp_tx_rollback_t_;
#[repr(C)]
pub struct Struct_amqp_tx_rollback_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_tx_rollback_ok_t = Struct_amqp_tx_rollback_ok_t_;
#[repr(C)]
pub struct Struct_amqp_confirm_select_t_ {
    pub nowait: amqp_boolean_t,
}
pub type amqp_confirm_select_t = Struct_amqp_confirm_select_t_;
#[repr(C)]
pub struct Struct_amqp_confirm_select_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_confirm_select_ok_t = Struct_amqp_confirm_select_ok_t_;
#[repr(C)]
pub struct Struct_amqp_connection_properties_t_ {
    pub _flags: amqp_flags_t,
    pub dummy: ::libc::c_char,
}
pub type amqp_connection_properties_t = Struct_amqp_connection_properties_t_;
#[repr(C)]
pub struct Struct_amqp_channel_properties_t_ {
    pub _flags: amqp_flags_t,
    pub dummy: ::libc::c_char,
}
pub type amqp_channel_properties_t = Struct_amqp_channel_properties_t_;
#[repr(C)]
pub struct Struct_amqp_access_properties_t_ {
    pub _flags: amqp_flags_t,
    pub dummy: ::libc::c_char,
}
pub type amqp_access_properties_t = Struct_amqp_access_properties_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_properties_t_ {
    pub _flags: amqp_flags_t,
    pub dummy: ::libc::c_char,
}
pub type amqp_exchange_properties_t = Struct_amqp_exchange_properties_t_;
#[repr(C)]
pub struct Struct_amqp_queue_properties_t_ {
    pub _flags: amqp_flags_t,
    pub dummy: ::libc::c_char,
}
pub type amqp_queue_properties_t = Struct_amqp_queue_properties_t_;
#[repr(C)]
pub struct Struct_amqp_basic_properties_t_ {
    pub _flags: amqp_flags_t,
    pub content_type: amqp_bytes_t,
    pub content_encoding: amqp_bytes_t,
    pub headers: amqp_table_t,
    pub delivery_mode: uint8_t,
    pub priority: uint8_t,
    pub correlation_id: amqp_bytes_t,
    pub reply_to: amqp_bytes_t,
    pub expiration: amqp_bytes_t,
    pub message_id: amqp_bytes_t,
    pub timestamp: uint64_t,
    pub _type: amqp_bytes_t,
    pub user_id: amqp_bytes_t,
    pub app_id: amqp_bytes_t,
    pub cluster_id: amqp_bytes_t,
}
pub type amqp_basic_properties_t = Struct_amqp_basic_properties_t_;
#[repr(C)]
pub struct Struct_amqp_tx_properties_t_ {
    pub _flags: amqp_flags_t,
    pub dummy: ::libc::c_char,
}
pub type amqp_tx_properties_t = Struct_amqp_tx_properties_t_;
#[repr(C)]
pub struct Struct_amqp_confirm_properties_t_ {
    pub _flags: amqp_flags_t,
    pub dummy: ::libc::c_char,
}
pub type amqp_confirm_properties_t = Struct_amqp_confirm_properties_t_;
#[repr(C)]
pub struct Struct_amqp_message_t_ {
    pub properties: amqp_basic_properties_t,
    pub body: amqp_bytes_t,
    pub pool: amqp_pool_t,
}
pub type amqp_message_t = Struct_amqp_message_t_;
#[repr(C)]
pub struct Struct_amqp_envelope_t_ {
    pub channel: amqp_channel_t,
    pub consumer_tag: amqp_bytes_t,
    pub delivery_tag: uint64_t,
    pub redelivered: amqp_boolean_t,
    pub exchange: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
    pub message: amqp_message_t,
}
pub type amqp_envelope_t = Struct_amqp_envelope_t_;
#[repr(C)]
pub struct Struct_amqp_connection_info {
    pub user: *mut ::libc::c_char,
    pub password: *mut ::libc::c_char,
    pub host: *mut ::libc::c_char,
    pub vhost: *mut ::libc::c_char,
    pub port: ::libc::c_int,
    pub ssl: amqp_boolean_t,
}
pub type __darwin_nl_item = ::libc::c_int;
pub type __darwin_wctrans_t = ::libc::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::libc::c_int;
pub type ssize_t = __darwin_ssize_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_int8_t = ::libc::c_uchar;
pub type u_int16_t = ::libc::c_ushort;
pub type u_int32_t = ::libc::c_uint;
pub type u_int64_t = ::libc::c_ulonglong;
pub type register_t = int64_t;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = int64_t;
pub type user_long_t = int64_t;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = int64_t;
pub type user_off_t = int64_t;
pub type syscall_arg_t = u_int64_t;
pub type u_char = ::libc::c_uchar;
pub type u_short = ::libc::c_ushort;
pub type u_int = ::libc::c_uint;
pub type u_long = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type _uint = ::libc::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::libc::c_char;
pub type daddr_t = int32_t;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = int32_t;
pub type swblk_t = int32_t;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
pub struct Struct_fd_set {
    pub fds_bits: [__int32_t, ..32u],
}
pub type fd_set = Struct_fd_set;
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type sa_family_t = __uint8_t;
pub type socklen_t = __darwin_socklen_t;
#[repr(C)]
pub struct Struct_iovec {
    pub iov_base: *mut ::libc::c_void,
    pub iov_len: size_t,
}
#[repr(C)]
pub struct Struct_linger {
    pub l_onoff: ::libc::c_int,
    pub l_linger: ::libc::c_int,
}
#[repr(C)]
pub struct Struct_so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
#[repr(C)]
pub struct Struct_sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::libc::c_char, ..14u],
}
#[repr(C)]
pub struct Struct_sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
#[repr(C)]
pub struct Struct_sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::libc::c_char, ..6u],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::libc::c_char, ..112u],
}
#[repr(C)]
pub struct Struct_msghdr {
    pub msg_name: *mut ::libc::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut Struct_iovec,
    pub msg_iovlen: ::libc::c_int,
    pub msg_control: *mut ::libc::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::libc::c_int,
}
#[repr(C)]
pub struct Struct_cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::libc::c_int,
    pub cmsg_type: ::libc::c_int,
}
#[repr(C)]
pub struct Struct_sf_hdtr {
    pub headers: *mut Struct_iovec,
    pub hdr_cnt: ::libc::c_int,
    pub trailers: *mut Struct_iovec,
    pub trl_cnt: ::libc::c_int,
}
#[repr(C)]
pub struct Struct_in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
pub struct Struct_sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: Struct_in_addr,
    pub sin_zero: [::libc::c_char, ..8u],
}
#[repr(C)]
pub struct Struct_ip_opts {
    pub ip_dst: Struct_in_addr,
    pub ip_opts: [::libc::c_char, ..40u],
}
#[repr(C)]
pub struct Struct_ip_mreq {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_interface: Struct_in_addr,
}
#[repr(C)]
pub struct Struct_ip_mreqn {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_address: Struct_in_addr,
    pub imr_ifindex: ::libc::c_int,
}
#[repr(C)]
pub struct Struct_ip_mreq_source {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_sourceaddr: Struct_in_addr,
    pub imr_interface: Struct_in_addr,
}
#[repr(C)]
pub struct Struct_group_req {
    pub gr_interface: uint32_t,
    pub gr_group: Struct_sockaddr_storage,
}
#[repr(C)]
pub struct Struct_group_source_req {
    pub gsr_interface: uint32_t,
    pub gsr_group: Struct_sockaddr_storage,
    pub gsr_source: Struct_sockaddr_storage,
}
#[repr(C)]
pub struct Struct___msfilterreq {
    pub msfr_ifindex: uint32_t,
    pub msfr_fmode: uint32_t,
    pub msfr_nsrcs: uint32_t,
    pub __msfr_align: uint32_t,
    pub msfr_group: Struct_sockaddr_storage,
    pub msfr_srcs: *mut Struct_sockaddr_storage,
}
#[repr(C)]
pub struct Struct_in_pktinfo {
    pub ipi_ifindex: ::libc::c_uint,
    pub ipi_spec_dst: Struct_in_addr,
    pub ipi_addr: Struct_in_addr,
}
#[repr(C)]
pub struct Struct_in6_addr {
    pub __u6_addr: Union_Unnamed5,
}
#[repr(C)]
pub struct Union_Unnamed5 {
    pub data: [u32, ..4u],
}
impl Union_Unnamed5 {
    pub fn __u6_addr8(&mut self) -> *mut [__uint8_t, ..16u] {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __u6_addr16(&mut self) -> *mut [__uint16_t, ..8u] {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __u6_addr32(&mut self) -> *mut [__uint32_t, ..4u] {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: Struct_in6_addr,
    pub sin6_scope_id: __uint32_t,
}
#[repr(C)]
pub struct Struct_ipv6_mreq {
    pub ipv6mr_multiaddr: Struct_in6_addr,
    pub ipv6mr_interface: ::libc::c_uint,
}
#[repr(C)]
pub struct Struct_in6_pktinfo {
    pub ipi6_addr: Struct_in6_addr,
    pub ipi6_ifindex: ::libc::c_uint,
}
#[repr(C)]
pub struct Struct_ip6_mtuinfo {
    pub ip6m_addr: Struct_sockaddr_in6,
    pub ip6m_mtu: uint32_t,
}
pub type Enum_uio_rw = ::libc::c_uint;
pub static UIO_READ: ::libc::c_uint = 0;
pub static UIO_WRITE: ::libc::c_uint = 1;
pub type amqp_socket_writev_fn =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut ::libc::c_void,
                               arg2: *mut Struct_iovec, arg3: ::libc::c_int)
                              -> ssize_t>;
pub type amqp_socket_send_fn =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut ::libc::c_void,
                               arg2: *const ::libc::c_void, arg3: size_t)
                              -> ssize_t>;
pub type amqp_socket_recv_fn =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut ::libc::c_void,
                               arg2: *mut ::libc::c_void, arg3: size_t,
                               arg4: ::libc::c_int) -> ssize_t>;
pub type amqp_socket_open_fn =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut ::libc::c_void,
                               arg2: *const ::libc::c_char,
                               arg3: ::libc::c_int, arg4: *mut Struct_timeval)
                              -> ::libc::c_int>;
pub type amqp_socket_close_fn =
    ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void)
                              -> ::libc::c_int>;
pub type amqp_socket_get_sockfd_fn =
    ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void)
                              -> ::libc::c_int>;
pub type amqp_socket_delete_fn =
    ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void)>;
#[repr(C)]
pub struct Struct_amqp_socket_class_t {
    pub writev: amqp_socket_writev_fn,
    pub send: amqp_socket_send_fn,
    pub recv: amqp_socket_recv_fn,
    pub open: amqp_socket_open_fn,
    pub close: amqp_socket_close_fn,
    pub get_sockfd: amqp_socket_get_sockfd_fn,
    pub delete: amqp_socket_delete_fn,
}
#[repr(C)]
pub struct Struct_amqp_socket_t_ {
    pub klass: *const Struct_amqp_socket_class_t,
}
#[repr(C)]
pub struct Struct_timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::libc::c_long,
}
#[repr(C)]
pub struct Struct_timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[repr(C)]
pub struct Struct_itimerval {
    pub it_interval: Struct_timeval,
    pub it_value: Struct_timeval,
}
#[repr(C)]
pub struct Struct_timezone {
    pub tz_minuteswest: ::libc::c_int,
    pub tz_dsttime: ::libc::c_int,
}
#[repr(C)]
pub struct Struct_clockinfo {
    pub hz: ::libc::c_int,
    pub tick: ::libc::c_int,
    pub tickadj: ::libc::c_int,
    pub stathz: ::libc::c_int,
    pub profhz: ::libc::c_int,
}
#[repr(C)]
pub struct Struct_tm {
    pub tm_sec: ::libc::c_int,
    pub tm_min: ::libc::c_int,
    pub tm_hour: ::libc::c_int,
    pub tm_mday: ::libc::c_int,
    pub tm_mon: ::libc::c_int,
    pub tm_year: ::libc::c_int,
    pub tm_wday: ::libc::c_int,
    pub tm_yday: ::libc::c_int,
    pub tm_isdst: ::libc::c_int,
    pub tm_gmtoff: ::libc::c_long,
    pub tm_zone: *mut ::libc::c_char,
}
#[repr(C)]
pub struct Struct_amqp_timer_t_ {
    pub current_timestamp: uint64_t,
    pub timeout_timestamp: uint64_t,
    pub ns_until_next_timeout: uint64_t,
    pub tv: Struct_timeval,
}
pub type amqp_timer_t = Struct_amqp_timer_t_;
pub type Enum_amqp_connection_state_enum_ = ::libc::c_uint;
pub static CONNECTION_STATE_IDLE: ::libc::c_uint = 0;
pub static CONNECTION_STATE_INITIAL: ::libc::c_uint = 1;
pub static CONNECTION_STATE_HEADER: ::libc::c_uint = 2;
pub static CONNECTION_STATE_BODY: ::libc::c_uint = 3;
pub type amqp_connection_state_enum = Enum_amqp_connection_state_enum_;
#[repr(C)]
pub struct Struct_amqp_link_t_ {
    pub next: *mut Struct_amqp_link_t_,
    pub data: *mut ::libc::c_void,
}
pub type amqp_link_t = Struct_amqp_link_t_;
#[repr(C)]
pub struct Struct_amqp_pool_table_entry_t_ {
    pub next: *mut Struct_amqp_pool_table_entry_t_,
    pub pool: amqp_pool_t,
    pub channel: amqp_channel_t,
}
pub type amqp_pool_table_entry_t = Struct_amqp_pool_table_entry_t_;
#[repr(C)]
pub struct Struct_amqp_connection_state_t_ {
    pub pool_table: [*mut amqp_pool_table_entry_t, ..16u],
    pub state: amqp_connection_state_enum,
    pub channel_max: ::libc::c_int,
    pub frame_max: ::libc::c_int,
    pub heartbeat: ::libc::c_int,
    pub header_buffer: [::libc::c_char, ..8u],
    pub inbound_buffer: amqp_bytes_t,
    pub inbound_offset: size_t,
    pub target_size: size_t,
    pub outbound_buffer: amqp_bytes_t,
    pub socket: *mut amqp_socket_t,
    pub sock_inbound_buffer: amqp_bytes_t,
    pub sock_inbound_offset: size_t,
    pub sock_inbound_limit: size_t,
    pub first_queued_frame: *mut amqp_link_t,
    pub last_queued_frame: *mut amqp_link_t,
    pub most_recent_api_result: amqp_rpc_reply_t,
    pub next_recv_heartbeat: uint64_t,
    pub next_send_heartbeat: uint64_t,
    pub server_properties: amqp_table_t,
    pub properties_pool: amqp_pool_t,
}
pub type __va_list_tag = Struct___va_list_tag;
#[repr(C)]
pub struct Struct___va_list_tag {
    pub gp_offset: ::libc::c_uint,
    pub fp_offset: ::libc::c_uint,
    pub overflow_arg_area: *mut ::libc::c_void,
    pub reg_save_area: *mut ::libc::c_void,
}
#[link(name = "rabbitmq")]
extern "C" {
    pub static amqp_empty_bytes: amqp_bytes_t;
    pub static amqp_empty_table: amqp_table_t;
    pub static amqp_empty_array: amqp_array_t;
    pub static in6addr_any: Struct_in6_addr;
    pub static in6addr_loopback: Struct_in6_addr;
    pub static in6addr_nodelocal_allnodes: Struct_in6_addr;
    pub static in6addr_linklocal_allnodes: Struct_in6_addr;
    pub static in6addr_linklocal_allrouters: Struct_in6_addr;
    pub static in6addr_linklocal_allv2routers: Struct_in6_addr;
    pub static mut tzname: *mut *mut ::libc::c_char;
    pub static mut getdate_err: ::libc::c_int;
    pub static mut timezone: ::libc::c_long;
    pub static mut daylight: ::libc::c_int;
    pub fn amqp_version_number() -> uint32_t;
    pub fn amqp_version() -> *const ::libc::c_char;
    pub fn amqp_constant_name(constantNumber: ::libc::c_int) ->
     *const ::libc::c_char;
    pub fn amqp_constant_is_hard_error(constantNumber: ::libc::c_int) ->
     amqp_boolean_t;
    pub fn amqp_method_name(methodNumber: amqp_method_number_t) ->
     *const ::libc::c_char;
    pub fn amqp_method_has_content(methodNumber: amqp_method_number_t) ->
     amqp_boolean_t;
    pub fn amqp_decode_method(methodNumber: amqp_method_number_t,
                              pool: *mut amqp_pool_t, encoded: amqp_bytes_t,
                              decoded: *mut *mut ::libc::c_void) ->
     ::libc::c_int;
    pub fn amqp_decode_properties(class_id: uint16_t, pool: *mut amqp_pool_t,
                                  encoded: amqp_bytes_t,
                                  decoded: *mut *mut ::libc::c_void) ->
     ::libc::c_int;
    pub fn amqp_encode_method(methodNumber: amqp_method_number_t,
                              decoded: *mut ::libc::c_void,
                              encoded: amqp_bytes_t) -> ::libc::c_int;
    pub fn amqp_encode_properties(class_id: uint16_t,
                                  decoded: *mut ::libc::c_void,
                                  encoded: amqp_bytes_t) -> ::libc::c_int;
    pub fn amqp_channel_open(state: amqp_connection_state_t,
                             channel: amqp_channel_t) ->
     *mut amqp_channel_open_ok_t;
    pub fn amqp_channel_flow(state: amqp_connection_state_t,
                             channel: amqp_channel_t, active: amqp_boolean_t)
     -> *mut amqp_channel_flow_ok_t;
    pub fn amqp_exchange_declare(state: amqp_connection_state_t,
                                 channel: amqp_channel_t,
                                 exchange: amqp_bytes_t, _type: amqp_bytes_t,
                                 passive: amqp_boolean_t,
                                 durable: amqp_boolean_t,
                                 arguments: amqp_table_t) ->
     *mut amqp_exchange_declare_ok_t;
    pub fn amqp_exchange_delete(state: amqp_connection_state_t,
                                channel: amqp_channel_t,
                                exchange: amqp_bytes_t,
                                if_unused: amqp_boolean_t) ->
     *mut amqp_exchange_delete_ok_t;
    pub fn amqp_exchange_bind(state: amqp_connection_state_t,
                              channel: amqp_channel_t,
                              destination: amqp_bytes_t, source: amqp_bytes_t,
                              routing_key: amqp_bytes_t,
                              arguments: amqp_table_t) ->
     *mut amqp_exchange_bind_ok_t;
    pub fn amqp_exchange_unbind(state: amqp_connection_state_t,
                                channel: amqp_channel_t,
                                destination: amqp_bytes_t,
                                source: amqp_bytes_t,
                                routing_key: amqp_bytes_t,
                                arguments: amqp_table_t) ->
     *mut amqp_exchange_unbind_ok_t;
    pub fn amqp_queue_declare(state: amqp_connection_state_t,
                              channel: amqp_channel_t, queue: amqp_bytes_t,
                              passive: amqp_boolean_t,
                              durable: amqp_boolean_t,
                              exclusive: amqp_boolean_t,
                              auto_delete: amqp_boolean_t,
                              arguments: amqp_table_t) ->
     *mut amqp_queue_declare_ok_t;
    pub fn amqp_queue_bind(state: amqp_connection_state_t,
                           channel: amqp_channel_t, queue: amqp_bytes_t,
                           exchange: amqp_bytes_t, routing_key: amqp_bytes_t,
                           arguments: amqp_table_t) ->
     *mut amqp_queue_bind_ok_t;
    pub fn amqp_queue_purge(state: amqp_connection_state_t,
                            channel: amqp_channel_t, queue: amqp_bytes_t) ->
     *mut amqp_queue_purge_ok_t;
    pub fn amqp_queue_delete(state: amqp_connection_state_t,
                             channel: amqp_channel_t, queue: amqp_bytes_t,
                             if_unused: amqp_boolean_t,
                             if_empty: amqp_boolean_t) ->
     *mut amqp_queue_delete_ok_t;
    pub fn amqp_queue_unbind(state: amqp_connection_state_t,
                             channel: amqp_channel_t, queue: amqp_bytes_t,
                             exchange: amqp_bytes_t,
                             routing_key: amqp_bytes_t,
                             arguments: amqp_table_t) ->
     *mut amqp_queue_unbind_ok_t;
    pub fn amqp_basic_qos(state: amqp_connection_state_t,
                          channel: amqp_channel_t, prefetch_size: uint32_t,
                          prefetch_count: uint16_t, global: amqp_boolean_t) ->
     *mut amqp_basic_qos_ok_t;
    pub fn amqp_basic_consume(state: amqp_connection_state_t,
                              channel: amqp_channel_t, queue: amqp_bytes_t,
                              consumer_tag: amqp_bytes_t,
                              no_local: amqp_boolean_t,
                              no_ack: amqp_boolean_t,
                              exclusive: amqp_boolean_t,
                              arguments: amqp_table_t) ->
     *mut amqp_basic_consume_ok_t;
    pub fn amqp_basic_cancel(state: amqp_connection_state_t,
                             channel: amqp_channel_t,
                             consumer_tag: amqp_bytes_t) ->
     *mut amqp_basic_cancel_ok_t;
    pub fn amqp_basic_recover(state: amqp_connection_state_t,
                              channel: amqp_channel_t,
                              requeue: amqp_boolean_t) ->
     *mut amqp_basic_recover_ok_t;
    pub fn amqp_tx_select(state: amqp_connection_state_t,
                          channel: amqp_channel_t) ->
     *mut amqp_tx_select_ok_t;
    pub fn amqp_tx_commit(state: amqp_connection_state_t,
                          channel: amqp_channel_t) ->
     *mut amqp_tx_commit_ok_t;
    pub fn amqp_tx_rollback(state: amqp_connection_state_t,
                            channel: amqp_channel_t) ->
     *mut amqp_tx_rollback_ok_t;
    pub fn amqp_confirm_select(state: amqp_connection_state_t,
                               channel: amqp_channel_t) ->
     *mut amqp_confirm_select_ok_t;
    pub fn init_amqp_pool(pool: *mut amqp_pool_t, pagesize: size_t);
    pub fn recycle_amqp_pool(pool: *mut amqp_pool_t);
    pub fn empty_amqp_pool(pool: *mut amqp_pool_t);
    pub fn amqp_pool_alloc(pool: *mut amqp_pool_t, amount: size_t) ->
     *mut ::libc::c_void;
    pub fn amqp_pool_alloc_bytes(pool: *mut amqp_pool_t, amount: size_t,
                                 output: *mut amqp_bytes_t);
    pub fn amqp_cstring_bytes(cstr: *const ::libc::c_char) -> amqp_bytes_t;
    pub fn amqp_bytes_malloc_dup(src: amqp_bytes_t) -> amqp_bytes_t;
    pub fn amqp_bytes_malloc(amount: size_t) -> amqp_bytes_t;
    pub fn amqp_bytes_free(bytes: amqp_bytes_t);
    pub fn amqp_new_connection() -> amqp_connection_state_t;
    pub fn amqp_get_sockfd(state: amqp_connection_state_t) -> ::libc::c_int;
    pub fn amqp_set_sockfd(state: amqp_connection_state_t,
                           sockfd: ::libc::c_int);
    pub fn amqp_tune_connection(state: amqp_connection_state_t,
                                channel_max: ::libc::c_int,
                                frame_max: ::libc::c_int,
                                heartbeat: ::libc::c_int) -> ::libc::c_int;
    pub fn amqp_get_channel_max(state: amqp_connection_state_t) ->
     ::libc::c_int;
    pub fn amqp_destroy_connection(state: amqp_connection_state_t) ->
     ::libc::c_int;
    pub fn amqp_handle_input(state: amqp_connection_state_t,
                             received_data: amqp_bytes_t,
                             decoded_frame: *mut amqp_frame_t) ->
     ::libc::c_int;
    pub fn amqp_release_buffers_ok(state: amqp_connection_state_t) ->
     amqp_boolean_t;
    pub fn amqp_release_buffers(state: amqp_connection_state_t);
    pub fn amqp_maybe_release_buffers(state: amqp_connection_state_t);
    pub fn amqp_maybe_release_buffers_on_channel(state:
                                                     amqp_connection_state_t,
                                                 channel: amqp_channel_t);
    pub fn amqp_send_frame(state: amqp_connection_state_t,
                           frame: *const amqp_frame_t) -> ::libc::c_int;
    pub fn amqp_table_entry_cmp(entry1: *const ::libc::c_void,
                                entry2: *const ::libc::c_void) ->
     ::libc::c_int;
    pub fn amqp_open_socket(hostname: *const ::libc::c_char,
                            portnumber: ::libc::c_int) -> ::libc::c_int;
    pub fn amqp_send_header(state: amqp_connection_state_t) -> ::libc::c_int;
    pub fn amqp_frames_enqueued(state: amqp_connection_state_t) ->
     amqp_boolean_t;
    pub fn amqp_simple_wait_frame(state: amqp_connection_state_t,
                                  decoded_frame: *mut amqp_frame_t) ->
     ::libc::c_int;
    pub fn amqp_simple_wait_frame_noblock(state: amqp_connection_state_t,
                                          decoded_frame: *mut amqp_frame_t,
                                          tv: *mut Struct_timeval) ->
     ::libc::c_int;
    pub fn amqp_simple_wait_method(state: amqp_connection_state_t,
                                   expected_channel: amqp_channel_t,
                                   expected_method: amqp_method_number_t,
                                   output: *mut amqp_method_t) ->
     ::libc::c_int;
    pub fn amqp_send_method(state: amqp_connection_state_t,
                            channel: amqp_channel_t, id: amqp_method_number_t,
                            decoded: *mut ::libc::c_void) -> ::libc::c_int;
    pub fn amqp_simple_rpc(state: amqp_connection_state_t,
                           channel: amqp_channel_t,
                           request_id: amqp_method_number_t,
                           expected_reply_ids: *mut amqp_method_number_t,
                           decoded_request_method: *mut ::libc::c_void) ->
     amqp_rpc_reply_t;
    pub fn amqp_simple_rpc_decoded(state: amqp_connection_state_t,
                                   channel: amqp_channel_t,
                                   request_id: amqp_method_number_t,
                                   reply_id: amqp_method_number_t,
                                   decoded_request_method:
                                       *mut ::libc::c_void) ->
     *mut ::libc::c_void;
    pub fn amqp_get_rpc_reply(state: amqp_connection_state_t) ->
     amqp_rpc_reply_t;
    pub fn amqp_login(state: amqp_connection_state_t,
                      vhost: *const ::libc::c_char,
                      channel_max: ::libc::c_int, frame_max: ::libc::c_int,
                      heartbeat: ::libc::c_int,
                      sasl_method: amqp_sasl_method_enum, ...) ->
     amqp_rpc_reply_t;
    pub fn amqp_login_with_properties(state: amqp_connection_state_t,
                                      vhost: *const ::libc::c_char,
                                      channel_max: ::libc::c_int,
                                      frame_max: ::libc::c_int,
                                      heartbeat: ::libc::c_int,
                                      properties: *const amqp_table_t,
                                      sasl_method: amqp_sasl_method_enum, ...)
     -> amqp_rpc_reply_t;
    pub fn amqp_basic_publish(state: amqp_connection_state_t,
                              channel: amqp_channel_t, exchange: amqp_bytes_t,
                              routing_key: amqp_bytes_t,
                              mandatory: amqp_boolean_t,
                              immediate: amqp_boolean_t,
                              properties:
                                  *const Struct_amqp_basic_properties_t_,
                              body: amqp_bytes_t) -> ::libc::c_int;
    pub fn amqp_channel_close(state: amqp_connection_state_t,
                              channel: amqp_channel_t, code: ::libc::c_int) ->
     amqp_rpc_reply_t;
    pub fn amqp_connection_close(state: amqp_connection_state_t,
                                 code: ::libc::c_int) -> amqp_rpc_reply_t;
    pub fn amqp_basic_ack(state: amqp_connection_state_t,
                          channel: amqp_channel_t, delivery_tag: uint64_t,
                          multiple: amqp_boolean_t) -> ::libc::c_int;
    pub fn amqp_basic_get(state: amqp_connection_state_t,
                          channel: amqp_channel_t, queue: amqp_bytes_t,
                          no_ack: amqp_boolean_t) -> amqp_rpc_reply_t;
    pub fn amqp_basic_reject(state: amqp_connection_state_t,
                             channel: amqp_channel_t, delivery_tag: uint64_t,
                             requeue: amqp_boolean_t) -> ::libc::c_int;
    pub fn amqp_basic_nack(state: amqp_connection_state_t,
                           channel: amqp_channel_t, delivery_tag: uint64_t,
                           multiple: amqp_boolean_t, requeue: amqp_boolean_t)
     -> ::libc::c_int;
    pub fn amqp_data_in_buffer(state: amqp_connection_state_t) ->
     amqp_boolean_t;
    pub fn amqp_error_string(err: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn amqp_error_string2(err: ::libc::c_int) -> *const ::libc::c_char;
    pub fn amqp_decode_table(encoded: amqp_bytes_t, pool: *mut amqp_pool_t,
                             output: *mut amqp_table_t, offset: *mut size_t)
     -> ::libc::c_int;
    pub fn amqp_encode_table(encoded: amqp_bytes_t, input: *mut amqp_table_t,
                             offset: *mut size_t) -> ::libc::c_int;
    pub fn amqp_table_clone(original: *mut amqp_table_t,
                            clone: *mut amqp_table_t, pool: *mut amqp_pool_t)
     -> ::libc::c_int;
    pub fn amqp_read_message(state: amqp_connection_state_t,
                             channel: amqp_channel_t,
                             message: *mut amqp_message_t,
                             flags: ::libc::c_int) -> amqp_rpc_reply_t;
    pub fn amqp_destroy_message(message: *mut amqp_message_t);
    pub fn amqp_consume_message(state: amqp_connection_state_t,
                                envelope: *mut amqp_envelope_t,
                                timeout: *mut Struct_timeval,
                                flags: ::libc::c_int) -> amqp_rpc_reply_t;
    pub fn amqp_destroy_envelope(envelope: *mut amqp_envelope_t);
    pub fn amqp_default_connection_info(parsed:
                                            *mut Struct_amqp_connection_info);
    pub fn amqp_parse_url(url: *mut ::libc::c_char,
                          parsed: *mut Struct_amqp_connection_info) ->
     ::libc::c_int;
    pub fn amqp_socket_open(_self: *mut amqp_socket_t,
                            host: *const ::libc::c_char, port: ::libc::c_int)
     -> ::libc::c_int;
    pub fn amqp_socket_open_noblock(_self: *mut amqp_socket_t,
                                    host: *const ::libc::c_char,
                                    port: ::libc::c_int,
                                    timeout: *mut Struct_timeval) ->
     ::libc::c_int;
    pub fn amqp_socket_get_sockfd(_self: *mut amqp_socket_t) -> ::libc::c_int;
    pub fn amqp_get_socket(state: amqp_connection_state_t) ->
     *mut amqp_socket_t;
    pub fn amqp_get_server_properties(state: amqp_connection_state_t) ->
     *mut amqp_table_t;
    pub fn memchr(arg1: *const ::libc::c_void, arg2: ::libc::c_int,
                  arg3: size_t) -> *mut ::libc::c_void;
    pub fn memcmp(arg1: *const ::libc::c_void, arg2: *const ::libc::c_void,
                  arg3: size_t) -> ::libc::c_int;
    pub fn memcpy(arg1: *mut ::libc::c_void, arg2: *const ::libc::c_void,
                  arg3: size_t) -> *mut ::libc::c_void;
    pub fn memmove(arg1: *mut ::libc::c_void, arg2: *const ::libc::c_void,
                   arg3: size_t) -> *mut ::libc::c_void;
    pub fn memset(arg1: *mut ::libc::c_void, arg2: ::libc::c_int,
                  arg3: size_t) -> *mut ::libc::c_void;
    pub fn strcat(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn strchr(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     *mut ::libc::c_char;
    pub fn strcmp(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) ->
     ::libc::c_int;
    pub fn strcoll(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn strcpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn strcspn(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> size_t;
    pub fn strerror(arg1: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn strlen(arg1: *const ::libc::c_char) -> size_t;
    pub fn strncat(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> *mut ::libc::c_char;
    pub fn strncmp(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> ::libc::c_int;
    pub fn strncpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> *mut ::libc::c_char;
    pub fn strpbrk(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn strrchr(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     *mut ::libc::c_char;
    pub fn strspn(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) ->
     size_t;
    pub fn strstr(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn strtok(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn strxfrm(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> size_t;
    pub fn strtok_r(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                    arg3: *mut *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn strerror_r(arg1: ::libc::c_int, arg2: *mut ::libc::c_char,
                      arg3: size_t) -> ::libc::c_int;
    pub fn strdup(arg1: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn memccpy(arg1: *mut ::libc::c_void, arg2: *const ::libc::c_void,
                   arg3: ::libc::c_int, arg4: size_t) -> *mut ::libc::c_void;
    pub fn stpcpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn stpncpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> *mut ::libc::c_char;
    pub fn strndup(arg1: *const ::libc::c_char, arg2: size_t) ->
     *mut ::libc::c_char;
    pub fn strnlen(arg1: *const ::libc::c_char, arg2: size_t) -> size_t;
    pub fn strsignal(sig: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn memset_s(arg1: *mut ::libc::c_void, arg2: rsize_t,
                    arg3: ::libc::c_int, arg4: rsize_t) -> errno_t;
    pub fn memmem(arg1: *const ::libc::c_void, arg2: size_t,
                  arg3: *const ::libc::c_void, arg4: size_t) ->
     *mut ::libc::c_void;
    pub fn memset_pattern4(arg1: *mut ::libc::c_void,
                           arg2: *const ::libc::c_void, arg3: size_t);
    pub fn memset_pattern8(arg1: *mut ::libc::c_void,
                           arg2: *const ::libc::c_void, arg3: size_t);
    pub fn memset_pattern16(arg1: *mut ::libc::c_void,
                            arg2: *const ::libc::c_void, arg3: size_t);
    pub fn strcasestr(arg1: *const ::libc::c_char,
                      arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn strnstr(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> *mut ::libc::c_char;
    pub fn strlcat(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> size_t;
    pub fn strlcpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> size_t;
    pub fn strmode(arg1: ::libc::c_int, arg2: *mut ::libc::c_char);
    pub fn strsep(arg1: *mut *mut ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn swab(arg1: *const ::libc::c_void, arg2: *mut ::libc::c_void,
                arg3: ssize_t);
    pub fn bcmp(arg1: *const ::libc::c_void, arg2: *const ::libc::c_void,
                arg3: size_t) -> ::libc::c_int;
    pub fn bcopy(arg1: *const ::libc::c_void, arg2: *mut ::libc::c_void,
                 arg3: size_t);
    pub fn bzero(arg1: *mut ::libc::c_void, arg2: size_t);
    pub fn index(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     *mut ::libc::c_char;
    pub fn rindex(arg1: *const ::libc::c_char, arg2: ::libc::c_int) ->
     *mut ::libc::c_char;
    pub fn ffs(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn strcasecmp(arg1: *const ::libc::c_char,
                      arg2: *const ::libc::c_char) -> ::libc::c_int;
    pub fn strncasecmp(arg1: *const ::libc::c_char,
                       arg2: *const ::libc::c_char, arg3: size_t) ->
     ::libc::c_int;
    pub fn ffsl(arg1: ::libc::c_long) -> ::libc::c_int;
    pub fn ffsll(arg1: ::libc::c_longlong) -> ::libc::c_int;
    pub fn fls(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn flsl(arg1: ::libc::c_long) -> ::libc::c_int;
    pub fn flsll(arg1: ::libc::c_longlong) -> ::libc::c_int;
    pub fn accept(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr,
                  arg3: *mut socklen_t) -> ::libc::c_int;
    pub fn bind(arg1: ::libc::c_int, arg2: *const Struct_sockaddr,
                arg3: socklen_t) -> ::libc::c_int;
    pub fn connect(arg1: ::libc::c_int, arg2: *const Struct_sockaddr,
                   arg3: socklen_t) -> ::libc::c_int;
    pub fn getpeername(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr,
                       arg3: *mut socklen_t) -> ::libc::c_int;
    pub fn getsockname(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr,
                       arg3: *mut socklen_t) -> ::libc::c_int;
    pub fn getsockopt(arg1: ::libc::c_int, arg2: ::libc::c_int,
                      arg3: ::libc::c_int, arg4: *mut ::libc::c_void,
                      arg5: *mut socklen_t) -> ::libc::c_int;
    pub fn listen(arg1: ::libc::c_int, arg2: ::libc::c_int) -> ::libc::c_int;
    pub fn recv(arg1: ::libc::c_int, arg2: *mut ::libc::c_void, arg3: size_t,
                arg4: ::libc::c_int) -> ssize_t;
    pub fn recvfrom(arg1: ::libc::c_int, arg2: *mut ::libc::c_void,
                    arg3: size_t, arg4: ::libc::c_int,
                    arg5: *mut Struct_sockaddr, arg6: *mut socklen_t) ->
     ssize_t;
    pub fn recvmsg(arg1: ::libc::c_int, arg2: *mut Struct_msghdr,
                   arg3: ::libc::c_int) -> ssize_t;
    pub fn send(arg1: ::libc::c_int, arg2: *const ::libc::c_void,
                arg3: size_t, arg4: ::libc::c_int) -> ssize_t;
    pub fn sendmsg(arg1: ::libc::c_int, arg2: *const Struct_msghdr,
                   arg3: ::libc::c_int) -> ssize_t;
    pub fn sendto(arg1: ::libc::c_int, arg2: *const ::libc::c_void,
                  arg3: size_t, arg4: ::libc::c_int,
                  arg5: *const Struct_sockaddr, arg6: socklen_t) -> ssize_t;
    pub fn setsockopt(arg1: ::libc::c_int, arg2: ::libc::c_int,
                      arg3: ::libc::c_int, arg4: *const ::libc::c_void,
                      arg5: socklen_t) -> ::libc::c_int;
    pub fn shutdown(arg1: ::libc::c_int, arg2: ::libc::c_int) ->
     ::libc::c_int;
    pub fn sockatmark(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn socket(arg1: ::libc::c_int, arg2: ::libc::c_int,
                  arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn socketpair(arg1: ::libc::c_int, arg2: ::libc::c_int,
                      arg3: ::libc::c_int, arg4: *mut ::libc::c_int) ->
     ::libc::c_int;
    pub fn sendfile(arg1: ::libc::c_int, arg2: ::libc::c_int, arg3: off_t,
                    arg4: *mut off_t, arg5: *mut Struct_sf_hdtr,
                    arg6: ::libc::c_int) -> ::libc::c_int;
    pub fn pfctlinput(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr);
    pub fn setipv4sourcefilter(arg1: ::libc::c_int, arg2: Struct_in_addr,
                               arg3: Struct_in_addr, arg4: uint32_t,
                               arg5: uint32_t, arg6: *mut Struct_in_addr) ->
     ::libc::c_int;
    pub fn getipv4sourcefilter(arg1: ::libc::c_int, arg2: Struct_in_addr,
                               arg3: Struct_in_addr, arg4: *mut uint32_t,
                               arg5: *mut uint32_t, arg6: *mut Struct_in_addr)
     -> ::libc::c_int;
    pub fn setsourcefilter(arg1: ::libc::c_int, arg2: uint32_t,
                           arg3: *mut Struct_sockaddr, arg4: socklen_t,
                           arg5: uint32_t, arg6: uint32_t,
                           arg7: *mut Struct_sockaddr_storage) ->
     ::libc::c_int;
    pub fn getsourcefilter(arg1: ::libc::c_int, arg2: uint32_t,
                           arg3: *mut Struct_sockaddr, arg4: socklen_t,
                           arg5: *mut uint32_t, arg6: *mut uint32_t,
                           arg7: *mut Struct_sockaddr_storage) ->
     ::libc::c_int;
    pub fn inet6_option_space(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_option_init(arg1: *mut ::libc::c_void,
                             arg2: *mut *mut Struct_cmsghdr,
                             arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_option_append(arg1: *mut Struct_cmsghdr,
                               arg2: *const __uint8_t, arg3: ::libc::c_int,
                               arg4: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_option_alloc(arg1: *mut Struct_cmsghdr, arg2: ::libc::c_int,
                              arg3: ::libc::c_int, arg4: ::libc::c_int) ->
     *mut __uint8_t;
    pub fn inet6_option_next(arg1: *const Struct_cmsghdr,
                             arg2: *mut *mut __uint8_t) -> ::libc::c_int;
    pub fn inet6_option_find(arg1: *const Struct_cmsghdr,
                             arg2: *mut *mut __uint8_t, arg3: ::libc::c_int)
     -> ::libc::c_int;
    pub fn inet6_rthdr_space(arg1: ::libc::c_int, arg2: ::libc::c_int) ->
     size_t;
    pub fn inet6_rthdr_init(arg1: *mut ::libc::c_void, arg2: ::libc::c_int) ->
     *mut Struct_cmsghdr;
    pub fn inet6_rthdr_add(arg1: *mut Struct_cmsghdr,
                           arg2: *const Struct_in6_addr, arg3: ::libc::c_uint)
     -> ::libc::c_int;
    pub fn inet6_rthdr_lasthop(arg1: *mut Struct_cmsghdr,
                               arg2: ::libc::c_uint) -> ::libc::c_int;
    pub fn inet6_rthdr_segments(arg1: *const Struct_cmsghdr) -> ::libc::c_int;
    pub fn inet6_rthdr_getaddr(arg1: *mut Struct_cmsghdr, arg2: ::libc::c_int)
     -> *mut Struct_in6_addr;
    pub fn inet6_rthdr_getflags(arg1: *const Struct_cmsghdr,
                                arg2: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_opt_init(arg1: *mut ::libc::c_void, arg2: socklen_t) ->
     ::libc::c_int;
    pub fn inet6_opt_append(arg1: *mut ::libc::c_void, arg2: socklen_t,
                            arg3: ::libc::c_int, arg4: __uint8_t,
                            arg5: socklen_t, arg6: __uint8_t,
                            arg7: *mut *mut ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_opt_finish(arg1: *mut ::libc::c_void, arg2: socklen_t,
                            arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_opt_set_val(arg1: *mut ::libc::c_void, arg2: ::libc::c_int,
                             arg3: *mut ::libc::c_void, arg4: socklen_t) ->
     ::libc::c_int;
    pub fn inet6_opt_next(arg1: *mut ::libc::c_void, arg2: socklen_t,
                          arg3: ::libc::c_int, arg4: *mut __uint8_t,
                          arg5: *mut socklen_t,
                          arg6: *mut *mut ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_opt_find(arg1: *mut ::libc::c_void, arg2: socklen_t,
                          arg3: ::libc::c_int, arg4: __uint8_t,
                          arg5: *mut socklen_t,
                          arg6: *mut *mut ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_opt_get_val(arg1: *mut ::libc::c_void, arg2: ::libc::c_int,
                             arg3: *mut ::libc::c_void, arg4: socklen_t) ->
     ::libc::c_int;
    pub fn inet6_rth_space(arg1: ::libc::c_int, arg2: ::libc::c_int) ->
     socklen_t;
    pub fn inet6_rth_init(arg1: *mut ::libc::c_void, arg2: socklen_t,
                          arg3: ::libc::c_int, arg4: ::libc::c_int) ->
     *mut ::libc::c_void;
    pub fn inet6_rth_add(arg1: *mut ::libc::c_void,
                         arg2: *const Struct_in6_addr) -> ::libc::c_int;
    pub fn inet6_rth_reverse(arg1: *const ::libc::c_void,
                             arg2: *mut ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_rth_segments(arg1: *const ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_rth_getaddr(arg1: *const ::libc::c_void, arg2: ::libc::c_int)
     -> *mut Struct_in6_addr;
    pub fn addrsel_policy_init();
    pub fn bindresvport(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr_in) ->
     ::libc::c_int;
    pub fn bindresvport_sa(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr) ->
     ::libc::c_int;
    pub fn inet_addr(arg1: *const ::libc::c_char) -> in_addr_t;
    pub fn inet_ntoa(arg1: Struct_in_addr) -> *mut ::libc::c_char;
    pub fn inet_ntop(arg1: ::libc::c_int, arg2: *const ::libc::c_void,
                     arg3: *mut ::libc::c_char, arg4: socklen_t) ->
     *const ::libc::c_char;
    pub fn inet_pton(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                     arg3: *mut ::libc::c_void) -> ::libc::c_int;
    pub fn ascii2addr(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                      arg3: *mut ::libc::c_void) -> ::libc::c_int;
    pub fn addr2ascii(arg1: ::libc::c_int, arg2: *const ::libc::c_void,
                      arg3: ::libc::c_int, arg4: *mut ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn inet_aton(arg1: *const ::libc::c_char, arg2: *mut Struct_in_addr)
     -> ::libc::c_int;
    pub fn inet_lnaof(arg1: Struct_in_addr) -> in_addr_t;
    pub fn inet_makeaddr(arg1: in_addr_t, arg2: in_addr_t) -> Struct_in_addr;
    pub fn inet_netof(arg1: Struct_in_addr) -> in_addr_t;
    pub fn inet_network(arg1: *const ::libc::c_char) -> in_addr_t;
    pub fn inet_net_ntop(arg1: ::libc::c_int, arg2: *const ::libc::c_void,
                         arg3: ::libc::c_int, arg4: *mut ::libc::c_char,
                         arg5: __darwin_size_t) -> *mut ::libc::c_char;
    pub fn inet_net_pton(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                         arg3: *mut ::libc::c_void, arg4: __darwin_size_t) ->
     ::libc::c_int;
    pub fn inet_neta(arg1: in_addr_t, arg2: *mut ::libc::c_char,
                     arg3: __darwin_size_t) -> *mut ::libc::c_char;
    pub fn inet_nsap_addr(arg1: *const ::libc::c_char,
                          arg2: *mut ::libc::c_uchar, arg3: ::libc::c_int) ->
     ::libc::c_uint;
    pub fn inet_nsap_ntoa(arg1: ::libc::c_int, arg2: *const ::libc::c_uchar,
                          arg3: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn readv(arg1: ::libc::c_int, arg2: *const Struct_iovec,
                 arg3: ::libc::c_int) -> ssize_t;
    pub fn writev(arg1: ::libc::c_int, arg2: *const Struct_iovec,
                  arg3: ::libc::c_int) -> ssize_t;
    pub fn amqp_os_error_string(err: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn amqp_os_socket_error() -> ::libc::c_int;
    pub fn amqp_os_socket_close(sockfd: ::libc::c_int) -> ::libc::c_int;
    pub fn amqp_set_socket(state: amqp_connection_state_t,
                           socket: *mut amqp_socket_t);
    pub fn amqp_socket_writev(_self: *mut amqp_socket_t,
                              iov: *mut Struct_iovec, iovcnt: ::libc::c_int)
     -> ssize_t;
    pub fn amqp_socket_send(_self: *mut amqp_socket_t,
                            buf: *const ::libc::c_void, len: size_t) ->
     ssize_t;
    pub fn amqp_socket_recv(_self: *mut amqp_socket_t,
                            buf: *mut ::libc::c_void, len: size_t,
                            flags: ::libc::c_int) -> ssize_t;
    pub fn amqp_socket_close(_self: *mut amqp_socket_t) -> ::libc::c_int;
    pub fn amqp_socket_delete(_self: *mut amqp_socket_t);
    pub fn amqp_open_socket_noblock(hostname: *const ::libc::c_char,
                                    portnumber: ::libc::c_int,
                                    timeout: *mut Struct_timeval) ->
     ::libc::c_int;
    pub fn amqp_queue_frame(state: amqp_connection_state_t,
                            frame: *mut amqp_frame_t) -> ::libc::c_int;
    pub fn amqp_put_back_frame(state: amqp_connection_state_t,
                               frame: *mut amqp_frame_t) -> ::libc::c_int;
    pub fn amqp_simple_wait_frame_on_channel(state: amqp_connection_state_t,
                                             channel: amqp_channel_t,
                                             decoded_frame: *mut amqp_frame_t)
     -> ::libc::c_int;
    pub fn asctime(arg1: *const Struct_tm) -> *mut ::libc::c_char;
    pub fn clock() -> clock_t;
    pub fn ctime(arg1: *const time_t) -> *mut ::libc::c_char;
    pub fn difftime(arg1: time_t, arg2: time_t) -> ::libc::c_double;
    pub fn getdate(arg1: *const ::libc::c_char) -> *mut Struct_tm;
    pub fn gmtime(arg1: *const time_t) -> *mut Struct_tm;
    pub fn localtime(arg1: *const time_t) -> *mut Struct_tm;
    pub fn mktime(arg1: *mut Struct_tm) -> time_t;
    pub fn strftime(arg1: *mut ::libc::c_char, arg2: size_t,
                    arg3: *const ::libc::c_char, arg4: *const Struct_tm) ->
     size_t;
    pub fn strptime(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                    arg3: *mut Struct_tm) -> *mut ::libc::c_char;
    pub fn time(arg1: *mut time_t) -> time_t;
    pub fn tzset();
    pub fn asctime_r(arg1: *const Struct_tm, arg2: *mut ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::libc::c_char) ->
     *mut ::libc::c_char;
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut Struct_tm) ->
     *mut Struct_tm;
    pub fn localtime_r(arg1: *const time_t, arg2: *mut Struct_tm) ->
     *mut Struct_tm;
    pub fn posix2time(arg1: time_t) -> time_t;
    pub fn tzsetwall();
    pub fn time2posix(arg1: time_t) -> time_t;
    pub fn timelocal(arg1: *mut Struct_tm) -> time_t;
    pub fn timegm(arg1: *mut Struct_tm) -> time_t;
    pub fn nanosleep(arg1: *const Struct_timespec, arg2: *mut Struct_timespec)
     -> ::libc::c_int;
    pub fn adjtime(arg1: *const Struct_timeval, arg2: *mut Struct_timeval) ->
     ::libc::c_int;
    pub fn futimes(arg1: ::libc::c_int, arg2: *const Struct_timeval) ->
     ::libc::c_int;
    pub fn lutimes(arg1: *const ::libc::c_char, arg2: *const Struct_timeval)
     -> ::libc::c_int;
    pub fn settimeofday(arg1: *const Struct_timeval,
                        arg2: *const Struct_timezone) -> ::libc::c_int;
    pub fn getitimer(arg1: ::libc::c_int, arg2: *mut Struct_itimerval) ->
     ::libc::c_int;
    pub fn gettimeofday(arg1: *mut Struct_timeval, arg2: *mut ::libc::c_void)
     -> ::libc::c_int;
    pub fn select(arg1: ::libc::c_int, arg2: *mut fd_set, arg3: *mut fd_set,
                  arg4: *mut fd_set, arg5: *mut Struct_timeval) ->
     ::libc::c_int;
    pub fn setitimer(arg1: ::libc::c_int, arg2: *const Struct_itimerval,
                     arg3: *mut Struct_itimerval) -> ::libc::c_int;
    pub fn utimes(arg1: *const ::libc::c_char, arg2: *const Struct_timeval) ->
     ::libc::c_int;
    pub fn amqp_get_monotonic_timestamp() -> uint64_t;
    pub fn amqp_timer_update(timer: *mut amqp_timer_t,
                             timeout: *mut Struct_timeval) -> ::libc::c_int;
    pub fn amqp_get_or_create_channel_pool(connection:
                                               amqp_connection_state_t,
                                           channel: amqp_channel_t) ->
     *mut amqp_pool_t;
    pub fn amqp_get_channel_pool(state: amqp_connection_state_t,
                                 channel: amqp_channel_t) -> *mut amqp_pool_t;
    pub fn amqp_try_recv(state: amqp_connection_state_t,
                         current_time: uint64_t) -> ::libc::c_int;
    pub fn amqp_abort(fmt: *const ::libc::c_char, ...);
    pub fn amqp_tcp_socket_new(state: amqp_connection_state_t) ->
     *mut amqp_socket_t;
    pub fn amqp_tcp_socket_set_sockfd(_self: *mut amqp_socket_t,
                                      sockfd: ::libc::c_int);
}
